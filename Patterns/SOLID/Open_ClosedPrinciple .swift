//
//  Open_ClosedPrinciple .swift
//  Patterns
//
//  Created by Vladislav Gushin on 22/11/2017.
//  Copyright © 2017 Vladislav Gushin. All rights reserved.
//

import Foundation
/*Принцип открытости/закрытости (Open/Closed Principle) можно сформулировать так:
 Сущности программы должны быть открыты для расширения, но закрыты для изменения.
 Суть этого принципа состоит в том, что система должна быть построена таким образом, что все ее последующие изменения должны быть реализованы с помощью добавления нового кода, а не изменения уже существующего.
 Рассмотрим простейший пример - класс повара:
 class Cook{
    public string Name { get; set; }
 
    public Cook(string name){
        this.Name = name;
    }
 
     public void MakeDinner(){
        Console.WriteLine("Чистим картошку");
        Console.WriteLine("Ставим почищенную картошку на огонь");
        Console.WriteLine("Сливаем остатки воды, разминаем варенный картофель в пюре");
        Console.WriteLine("Посыпаем пюре специями и зеленью");
        Console.WriteLine("Картофельное пюре готово");
     }
 }
 И с помощью метода MakeDinner любой объект данного класса сможет сделать картофельного пюре:
 Cook bob = new Cook("Bob");
 bob.MakeDinner();
 
 Однако одного умения готовить картофельное пюре для повара вряд ли достаточно. Хотелось бы, чтобы повар мог приготовить еще что-то. И в этом случае мы подходим к необходимости изменения функционала класса, а именно метода MakeDinner. Но в соответствии с рассматриваемым нами принципом классы должны быть открыты для расширения, но закрыты для изменения. То есть, нам надо сделать класс Cook отрытым для расширения, но при этом не изменять.
 
 Для решения этой задачи мы можем воспользоваться паттерном Стратегия. В первую очередь нам надо вынести из класса и инкапсулировать всю ту часть, которая представляет изменяющееся поведение. В нашем случае это метод MakeDinner. Однако это не всегда бывает просто сделать. Возможно, в классе много методов, но на начальном этапе сложно определить, какие из них будут изменять свое поведение и как изменять. В этом случае, конечно, надо анализировать возможные способы изменения и уже на основании анализа делать выводы. То есть, все, что подается изменению, выносится из класса и инкапсулируется во вне - во внешних сущностях.
 */

protocol IMeal {
    func make()
}

class Cook {
    var name: String

    init(name: String) {
        self.name = name
    }

    func makeDinner(meal: IMeal) {
        meal.make()
    }
}

class PotatoMeal: IMeal {
    func make() {
        print("Чистим картошку")
        print("Ставим почищенную картошку на огонь")
        print("Сливаем остатки воды, разминаем варенный картофель в пюре")
        print("Посыпаем пюре специями и зеленью")
        print("Картофельное пюре готово")
    }
}

class SaladMeal: IMeal {
    func make() {
        print("Нарезаем помидоры и огурцы")
        print("Посыпаем зеленью, солью и специями")
        print("Поливаем подсолнечным маслом")
        print("Салат готов")
    }
}

class OpenClosedPrinciple: PClient {
    func test() {
        let cook = Cook(name: "Tom")
        cook.makeDinner(meal: SaladMeal())
        cook.makeDinner(meal: PotatoMeal())
    }
}


